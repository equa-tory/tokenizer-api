from fastapi import FastAPI, Depends, HTTPException, Query
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from app.models import *
from time import sleep
from typing import Optional

from app.db import get_db
from fastapi import FastAPI
from app.routers import admin_users, user_courses

app = FastAPI(title="Courses & Tickets API")

app.include_router(admin_users.router, prefix="/users", tags=["admin"])
# app.include_router(admin_courses.router, prefix="/courses", tags=["admin"])
# app.include_router(admin_tickettypes.router, prefix="/tickettypes", tags=["admin"])

app.include_router(user_courses.router, tags=["user"])
# engine = create_engine(DATABASE_URL)
# SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
# Base.metadata.create_all(bind=engine)



#region --- Admin CRUD endpoints ---
# POST /users
# @app.post("/users/")
# def create_user(name: str, course_id: int, tg_id: Optional[str] = None, db: Session = Depends(get_db)):
#     db_user = User(tg_id=tg_id, name=name, course_id=course_id)
#     db.add(db_user)
#     db.commit()
#     db.refresh(db_user)
#     return db_user
# @app.post("/users/")
# def upsert_user(
#     id: Optional[int] = None,
#     name: Optional[str] = None,
#     course_id: Optional[int] = None,
#     tg_id: Optional[str] = None,
#     db: Session = Depends(get_db)
# ):
#     # --- UPDATE ---
#     if id is not None:
#         user = db.query(User).filter(User.id == id).first()
#         if not user:
#             raise HTTPException(status_code=404, detail="User not found")

#         if name is not None:
#             user.name = name
#         if course_id is not None:
#             user.course_id = course_id
#         if tg_id is not None:
#             user.tg_id = tg_id

#         db.commit()
#         db.refresh(user)
#         return {"mode": "updated", "user": user}

#     # --- CREATE ---
#     if name is None or course_id is None:
#         raise HTTPException(status_code=400, detail="name and course_id are required")

#     user = User(
#         name=name,
#         course_id=course_id,
#         tg_id=tg_id
#     )

#     db.add(user)
#     db.commit()
#     db.refresh(user)
#     return {"mode": "created", "user": user}

# # POST /tickettypes
# @app.post("/tickettypes/")
# def create_ticket_type(name: str, max_per_user: int, require_time: int = None, db: Session = Depends(get_db)):
#     db_tt = TicketType(name=name, max_per_user=max_per_user, require_time=require_time)
#     db.add(db_tt)
#     db.commit()
#     db.refresh(db_tt)
#     return db_tt
# @app.post("/tickettypes/")
# def upsert_ticket_type(
#     id: Optional[int] = None,
#     name: Optional[str] = None,
#     max_per_user: Optional[int] = None,
#     require_time: Optional[int] = None,
#     db: Session = Depends(get_db)
# ):
#     # --- UPDATE ---
#     if id is not None:
#         tt = db.query(TicketType).filter(TicketType.id == id).first()
#         if not tt:
#             raise HTTPException(status_code=404, detail="TicketType not found")

#         if name is not None:
#             tt.name = name
#         if max_per_user is not None:
#             tt.max_per_user = max_per_user
#         if require_time is not None:
#             tt.require_time = require_time

#         db.commit()
#         db.refresh(tt)
#         return {"mode": "updated", "ticket_type": tt}

#     # --- CREATE ---
#     if name is None or max_per_user is None:
#         raise HTTPException(status_code=400, detail="name and max_per_user are required")

#     tt = TicketType(
#         name=name,
#         max_per_user=max_per_user,
#         require_time=require_time
#     )

#     db.add(tt)
#     db.commit()
#     db.refresh(tt)
#     return {"mode": "created", "ticket_type": tt}

# # POST /courses
# @app.post("/courses/")
# def create_course(name: str,
#                 weekday: int = 4,
#                 start_time: str = "16:00:00",
#                 end_time: str = "18:00:00",
#                 slot_range: int = 10,
#                 ticket_type_ids: list[int] = Query(default=[]),
#                 db: Session = Depends(get_db)):
#     db_course = Course(name=name, weekday=weekday, start_time=start_time, end_time=end_time, slot_range=slot_range)
#     if ticket_type_ids:
#         db_course.ticket_types = db.query(TicketType).filter(TicketType.id.in_(ticket_type_ids)).all()
#     db.add(db_course)
#     db.commit()
#     db.refresh(db_course)
#     return db_course
# @app.post("/courses/")
# def upsert_course(
#     id: Optional[int] = None,
#     name: Optional[str] = None,
#     weekday: Optional[int] = None,
#     start_time: Optional[str] = None,
#     end_time: Optional[str] = None,
#     slot_range: Optional[int] = None,
#     ticket_type_ids: list[int] = Query(default=[]),
#     db: Session = Depends(get_db),
# ):
#     # --- UPDATE ---
#     if id is not None:
#         course = db.query(Course).filter(Course.id == id).first()
#         if not course:
#             raise HTTPException(status_code=404, detail="Course not found")

#         if name is not None:
#             course.name = name
#         if weekday is not None:
#             course.weekday = weekday
#         if start_time is not None:
#             course.start_time = start_time
#         if end_time is not None:
#             course.end_time = end_time
#         if slot_range is not None:
#             course.slot_range = slot_range

#         if ticket_type_ids:
#             course.ticket_types = db.query(TicketType).filter(
#                 TicketType.id.in_(ticket_type_ids)
#             ).all()

#         db.commit()
#         db.refresh(course)
#         return {"mode": "updated", "course": course}

#     # --- CREATE ---
#     if name is None:
#         raise HTTPException(status_code=400, detail="name is required for create")

#     course = Course(
#         name=name,
#         weekday=weekday or 4,
#         start_time=start_time or "16:00:00",
#         end_time=end_time or "18:00:00",
#         slot_range=slot_range or 10,
#     )

#     if ticket_type_ids:
#         course.ticket_types = db.query(TicketType).filter(
#             TicketType.id.in_(ticket_type_ids)
#         ).all()

#     db.add(course)
#     db.commit()
#     db.refresh(course)

#     return {"mode": "created", "course": course}

# # POST /tickets
# @app.post("/tickets/")
# def create_ticket(name: str, status: str, user_id: int, ticket_type_id: int, db: Session = Depends(get_db)):
#     db_ticket = Ticket(
#         name=name,
#         status=status,
#         user_id=user_id,
#         ticket_type_id=ticket_type_id
#     )
#     db.add(db_ticket)
#     db.commit()
#     db.refresh(db_ticket)
#     return db_ticket

# GET /all
# @app.get("/all/")
# def get_all(db: Session = Depends(get_db)):
#     users = db.query(User).all()
#     courses = db.query(Course).all()
#     ticket_types = db.query(TicketType).all()
#     tickets = db.query(Ticket).all()
#     return {
#         "users": users,
#         "courses": courses,
#         "ticket_types": ticket_types,
#         "tickets": tickets
#     }
@app.get("/all/")
def get_all(db: Session = Depends(get_db)):
    users = db.query(User).all()
    courses = db.query(Course).all()
    ticket_types = db.query(TicketType).all()
    tickets = db.query(Ticket).all()

    # Создаём словарь course_id → список типов билетов
    course_tt_map = {}
    for course in courses:
        course_tt_map[course.id] = [{"id": tt.id, "name": tt.name, "max_per_user": tt.max_per_user, "require_time": tt.require_time} 
                                    for tt in course.ticket_types]

    # Формируем JSON с типами внутри курса
    courses_out = []
    for course in courses:
        courses_out.append({
            "id": course.id,
            "name": course.name,
            "weekday": course.weekday,
            "start_time": course.start_time.strftime("%H:%M:%S"),
            "end_time": course.end_time.strftime("%H:%M:%S"),
            "slot_range": course.slot_range,
            "ticket_types": course_tt_map.get(course.id, [])
        })

    return {
        "users": [{"id": u.id, "name": u.name, "tg_id": u.tg_id, "course_id": u.course_id} for u in users],
        "courses": courses_out,
        "ticket_types": [{"id": tt.id, "name": tt.name, "max_per_user": tt.max_per_user, "require_time": tt.require_time} for tt in ticket_types],
        "tickets": [{"id": t.id, "name": t.name, "status": t.status, "user_id": t.user_id, "ticket_type_id": t.ticket_type_id, "timestamp": t.timestamp.isoformat() if t.timestamp else None} for t in tickets]
    }
#endregion



#region --- User endpoints ---

# @app.get("/get_valid_types/{course_id}")
# def get_valid_types(course_id: int, db: Session = Depends(get_db)):
#     course = db.query(Course).filter(Course.id == course_id).first()
#     if not course:
#         raise HTTPException(status_code=404, detail="Course not found")
    
#     types = [{"id": tt.id, "name": tt.name, "max_per_user": tt.max_per_user, "require_time": tt.require_time} 
#              for tt in course.ticket_types]
    
#     return {"valid_types": types}

#endregion
